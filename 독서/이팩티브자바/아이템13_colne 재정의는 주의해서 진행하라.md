### Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만,<br>아쉽게도 의도한 목적을 제대로 이루지 못했다
* clone 메서드의 일반 규약은 허술하다
* Object 명세에서 가져온 다음 설명을 보자
```
이 객체의 복사본을 생성해 반환한다. '복사'의 정확한 뜻은 그 객체를 구현한 클래스에 따라
다를 수 있다. 일반적인 의도는 다음과 같다. 어떤 객체 x에 대해 다음 식은 참이다.
x.clone() != x

또한 다음 식도 참이다.
x.clone().getClass() == x.getClass()

하지만 이상의 요구를 반드시 만족해야 하는 것은 아니다.
한편 다음 식도 일반적으로 참이지만, 역시 필수는 아니다.
x.clone().equals(x)

관례상, 이 메서드가 반환하는 객체는 super.clone을 호출해 얻어야 한다. 이 클래스와
(object를 제외한)모든 상위 클래스가 이 관례를 따른다면 다음 식은 참이다.
x.clone().getClass() == x.getClass()

관례상, 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하려면 super.clone으로
얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다
```

* Cloneable 아키텍처는 '가변 객체를 참조하는 필드는 final로 선언하라'는 일반 용법과 충돌한다

```
새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안 되며, 새로운 클래스도 이를
구현해서는 안 된다. 

final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 
별다른 문제가 없을 때만 드물게 허용해야 한다. 

기본 원칙은 '복제 기능은 생성자와 팩터리를 이용하는게 최고'라는 것이다. 
단, 배열만은 clone 메서드 방식이 가장 깔끔한 ,이 규칙의 합당한 예외라 할 수 있다.
```