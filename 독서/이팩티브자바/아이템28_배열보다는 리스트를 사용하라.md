* 배열은 공변이고 제네릭은 불공변이다

```java
// [런타임에 실패한다]
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다.";

// [컴파일되지 않는다]
List<Object> ol = new ArrayList<Long>();
ol.add("타입이 달라 넣을 수 없다.");
```

* 배열은 실체화 된다
  * 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다
* 제네릭은 타입 정보가 런타임에는 소거된다
  * 원소 타입을 컴파일타임에만 검사하며 런타임에는 알수없다
  * 소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘이다
* 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분은 배열인 E[] 대신<br>
컬렉션인 List<E>를 사용하면 해결된다

```
배열과 제네릭에는 매우 다른 타입 규칙이 적용된다. 배열은 공변이고 실체화되는 반면,
제네릭은 불공변이고 타입 정보가 소거된다. 그 결과 배열은 런타임에는 타입 안전하지만
컴파일 타임에는 그렇지 않다. 제네릭은 반대다. 그래서 둘을 섞어 쓰기란 쉽지 않다.
둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을
적용해보자.
```