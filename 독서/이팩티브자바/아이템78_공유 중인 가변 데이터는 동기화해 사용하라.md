* 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메서드나 블록에<br>
들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다
* 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다
* 쓰기와 읽기 모두가 동기화되지 않으면 동작을 보장하지 않는다
* 배타적 실행 없이 통신의 목적만 필요하다면 volatile 한정자를 사용하면 성능을 높일 수 있다
  * 항상 가장 최근에 기록된 값을 읽게 됨을 보장한다
* 증가 연산자(++) 와 같은 연산이 필요하면 volatile 만으로는 안전 실패(safety failure)가 발생하기<br> 
때문에 synchronized 한정자를 붙여야 한다
* java.util.concurrent.atomic 패키지 클래스들은 배타적 실행과 안정적인 통신을 지원하면서 성능도 동기화 버전보다 우수하다
* `애초에 가변데이터는 공유하지 않는것이 가장 안전하다`

```
여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다.
동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수도 있다. 공유되는
가변 데이터를 동기화하는데 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다.
이는 디버깅 난이도가 가장 높은 문제에 속한다. 간헐적이거나 특정 타이밍에만 발생할 수도 있고,
VM에 따라 현상이 달라지기도 한다. 배타적 실행은 필요 없고 스레드끼리의 통신만 필요하다면 volatile
한정자만으로 동기화할 수 있다. 다만 올바로 사용하기가 까다롭다.
```