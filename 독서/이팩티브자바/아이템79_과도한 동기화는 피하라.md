* 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다
  * 동기화 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안되며, 클라이언트가 넘겨준 함수 객체를 호출해서도 안된다
  * 교착상태에 빠지거나 데이터 훼손이 발생할 수 있다
* 자바 언어의 락은 재진입을 허용하므로 교착상태에 빠지지는 않는다
  * 재진입 가능 락은 객체 지향 멀티스레드 프로그램을 쉽게 수현할 수 있도록 해주지만, 교착상태를 안전 실패(데이터 훼손)으로 변모시킬 수도 있다
  * 다행히 이런 문제는 외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 어렵지 않게 해결할 수 있다
  * 리스트 복사만 동기화 영역 안에 위치하거나 CopyOnWriteArrayList를 사용할 수 있다
* 동기화 영역에서는 가능한 한 일을 적게하자
* 멀티코어가 일반화된 오늘날, 과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU 시간이 아니다
  * 바로 경쟁하느라 낭비하는 시간, 즉 병렬로 실행할 기회를 읽고, 모든 코어가 메모리를 일관되게 보기 위한 지연시간이 진짜 비용이다
    * 가상머신의 코드 최적화를 제한한다는 점도 숨은 비용이다
* 가변클래스를 작성하려거든 동기화를 전혀 하지 말거나, 그 클래스를 사용해야하는 클래스가 외부에서 동기화하게 하자
* 클래스를 내부에서 동기화하기로 했다면 락 분할, 락 스트라이핑, 비차단 동시성 제어등 다양한 기법으로 동시성을 높여줄 수 있다
```
교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자.
일반화해 이야기하면, 동기화 영역 안에서의 작업은 최소한으로 줄이자. 가변 클래스를 설계할 때는
스스로 동기화해야 할지 고민하자. 멀티코어 세상인 지금은 과도한 동기화를 피하는게 과거 어느 때보다
중요하다. 합당한 이유가 있을 때만 내부에서 동기화하고, 동기화했는지 여부를 문서에 명확히 밝히자(아이템82).
```