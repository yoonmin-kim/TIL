* wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자
* 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다
  * 동시성을 무력화하지 못하므로 여러 메서드를 원자적으로 묶어 호출하는 일 역시 불가능하다
* Collections.synchronizedMap보다는 ConcurrentHashMap을 사용하는게 훨씬 좋다
  * 동기화된 맵을 동시성 맵으로 교체하는 것만으로 동시성 애플리케이션의 성능이 극적으로 개선된다
* 동기화 장치는 스레드가 다른 스레드를 기다릴 수 있게 하여, 서로 작업을 조율할 수 있게 해준다
  * CountDownLatch와 Semaphore가 가장많이 쓰이며 CyclicBarrier와 Exchanger는 그보다 덜 쓰인다
  * 가장 강력한 동기화 장치는 Phaser다
* 시간 간격을 잴 때는 항상 System.currentTimeMillis가 아닌 System.nanoTime을 사용하자
  * 더 정확하고 정밀하며 시스템의 실시간 시계의 시간 보정에 영향을 받지 않는다
* wait 메서드를 사용할 때는 반드시 대기 반복문(wait loop)관용구를 사용하라. 반복문 밖에서는 절대로 호출하지 말자
  * 이 반복문은 wait 호출 전후로 조건이 만족하는지를 검사하는 역할을 한다
* 외부로 공개된 객체에 대해 실수로 혹은 악의적으로 notify를 호출하는 상황에 대비하기 위해 wait를 반복문 안에서 호출했듯,<br>
notify대신 notifyAll을 사용하면 관련 없는 스레드가 실수로 혹은 악의적으로 wait를 호출하는 공격으로부터 보호할 수 있다

```
wait와 notify를 직접 사용하는 것은 동시성 '어셈블리 언어'로 프로그래밍하는 것에
비유할 수 있다. 반면 java.util.concurrent는 고수준 언어에 비유할 수 있다. 코드를
새로 작성한다면 wait와 notify를 쓸 이유가 거의(어쩌면 전혀)없다. 이들을 사용하는
레거시 코드를 유지보수해야 한다면 wait는 항상 표준 관용구에 따라 while문 안에서
호출하도록 하자. 일반적으로 notify보다는 notifyAll을 사용해야 한다. 혹시라도
notify를 사용한다면 응답 불가 상태에 빠지지 않도록 각별히 주의하자.
```