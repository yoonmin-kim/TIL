* Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다
  * 클래스가 Serializble을 구현하면 직렬화된 바이트 스트림 인코딩(직렬화 형태)도 하나의 공개 API가 된다
* Serializable 구현의 두 번째 문제는 버그와 보안 구멍이 생길 위험이 높아진다는 점이다
  * 직렬화는 언어의 기본 메커니즘을 우회하는 객체 생성 기법이다
    * 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다
* Serializable 구현의 세 번째 문제는 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다는 점이다
  * 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는지, 그리고 그<br>
  반대도 가능한지를 검사해야 한다
* 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 대부분 Serialiable을 확장해서는 안된다
* 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하다면 finalize 매서드를 재정의 하지 못하게 해야한다
* 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 다음의 readObjectNodata 메서드를 반드시 추가해야 한다
```java
private void readObjectNoData() throws InvalidObjectException {
    throw new InvalidObjectException("스트림 데이터가 필요합니다.");
}
```

* 내부 클래스는 직렬화를 구현하지 말아야 한다
  * 내부 클래스에 대한 기본 직렬화 형태는 분명하지 않다

```
Serializable은 구현한다고 선언하기는 아주 쉽지만, 그것은 눈속임일 뿐이다. 한 클래스의 여러 버전이
상호작용할 일이 없고 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등, 보호된 환경에서만 쓰일
클래스가 아니라면 Serializable 구현은 아주 신중하게 이뤄져야 한다. 상속할 수 있는 클래스라면
주의사항이 더욱 많아진다.
```