### 반복자 패턴
* 컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법
* 각 항목에 일일이 접근할 수 있게 해주는 기능을 집합체가 아닌 반복자 객체가 책임진다는 장점도 있다
* 그러면 집합체 인터페이스 구현이 간단해지고, 각자에게 중요한 일을 처리할 수 있게 된다
```
컬렉션 객체 안에 들어있는 모든 항목에 접근하는 방식이 통일되어 있으면 종류에 관계없이 모든
집합체에 사용할 수 있는 다형적인 코드를 만들 수 있다

Iterator 객체만 있으면 메뉴 항목이 배열로 저장되어 있든 ArrayList로 저장되어 있든 신경 쓰지
않고 작업을 처리할 수 있다
```

### 디자인 원칙
 * 단일 책임(역할) 원칙
   * 어떤 클래스가 바뀌는 이유는 하나뿐이어야 한다
   * 어떤 클래스에서 맡고 있는 모든 역할은 나중에 코드 변화를 불러올 수 있다
   * 역할이 2개 이상 있으면 바뀔수 있는 부분이 2개이상 되는것이다
   * 하나의 클래스는 하나의 역할만 해야한다

### 컴포지트 패턴
* 객체를 트리구조로 구성해서 부분-전체 계층구조를 구현한다
  * 부분-전체구조 : 부분(메뉴 및 메뉴 항목)들이 계층을 이루고 있지만 모든 부분을 묶어서 전체로 다룰 수 있는 구조
* 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있다
```
책에서 사용한 예제의 컴포지트 패턴에서는 계층구조를 관리하는 일과 메뉴 관련 작업을 처리한다
단일 역할 원칙을 깨는 대신 투명성을 확보하는 패턴이다
투명성: Component 인터페이스에 자식들을 관리하는 기능과 잎으로써의 기능을 전부 넣어서 클라이언트가
복합 객체와 잎을 똑같은 방식으로 처리할 수 있도록 만들 수 있다

=> 상황에 따라 원칙을 적절하게 사용해야 함을 보여주는 대표 사례라고 할 수 있다
```
