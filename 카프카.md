## 아파치 카프카 TOOL
<em><u>모두 JAVA기반이다.</u></em> <br>
`프로듀서` : 데이터 넣는역할 <br>
`토픽` : 프로듀서가 넣은 데이터가 토픽에 들어간다<br>
`컨슈머` : 토픽에 있는 데이터를 가져가는 역할<br>
`스트림즈` : 토픽에 있는 데이터를 StateFull, StateLess 하게 어떠한 처리를 해서 다시 토픽에 넣는역할 <br>
`커넥트` : 
1. 데이터 파이프라인을 연결하는 가장 핵심적인 tool 이다
2. 일반적인 프로듀서, 컨슈머와의 차이점은 클러스터로 운영이 가능하고, 템플릿형태로써 반복적으로 여러번 생성이 가능하다
```
프로듀서, 컨슈머를 개별로 운영하는것보다 훨씬 효율적인데, REST-API 
로 커넥트에 통신을 하여 반복적으로 만들 수 있다는 장점이 있다
```
* 커넥트(소스) : 
  * 프로듀서 역할 
  * 특정 데이터베이스나 소스 애플리케이션으로 부터  데이터를 가져와서 토픽에 넣는역할
* 커넥트(싱크) : 
  * 컨슈머 역할
  * 타겟 애플리케이션으로 데이터를 보내는 역할
___

## 카프카 브로커와 클러스터
`주키퍼` : 카프카 클러스터를 운영하기 위해 반드시 필요한 애플리케이션, 버전2까지는 필수이며 버전3부터는 주키퍼 없이 클러스터 운영이 가능하다(단, 아직 완벽하진 않음)
```
- 한개의 카프카 클러스터는 여러개의 브로커로 이루어져 있다
- 한개의 브로커는 한개의 Physical-Machine 이나 서버 혹은 Instance에서 동작하게 된다
- 상용환경에서 최소한 3개의 브로커를 운용하는게 일반적이고 데이터량이 많고 확장이 
 필요한 경우에는 50~100개까지 운영하는 경우도 있다
- 또는 상황에 따라서 클러스터를 2~3개로 나눠서 운영하는 경우도있다
```
`브로커` : 데이터를 분산저장하여 장애가 나더라도 데이터를 안전하게 사용할 수 있도록 도와주는 애플리케이션
___
## 카프카 클러스터와 주키퍼
`클러스터` : 
* 카프카 클러스터를 실행하기 위해서는 주키퍼가 필요함
* 여러대를 동시에 운영하는 경우도 많음(주키퍼 앙상블) 여러대를 운영하기 위해서는
* 주키퍼의 서로 다른 znode에 클러스터를 지정하면 되며, root znode에 <br>
각 클러스터별 znode를 생성하고 클러스터 실행시 root가 아닌 하위 znode로 설정
* 카프카3버전 부터는 주키퍼가 없어도 클러스터 동작 가능
___
## 브로커의 역할 - 컨트롤러, 데이터 삭제
`컨트롤러` :
* 다수의 브로커중 한대가 컨트롤러 역할을 한다
* 다른 브로커들의 상태체크, 브로커가 클러스터에서 빠지는 경우에(어떠한 이슈가 생겼을 경우) 브로커에 존재하는<br> 리더파티션을 재분배 한다
* 카프카는 지속적으로 데이터를 처리해야 하므로 비정상적인 브로커를 빠르게 클러스터에서 빼내는 것이 중요하다
* 컨트롤러 역할을 하는 브로커가 장애가 생기면 다른 브로커가 역할을 대신한다
```
데이터삭제:
- 다른 메시징 플랫폼과는 다르게 컨슈머가 데이터를 가져가도 토픽의 데이터는 삭제되지 않는다
- 데이터 삭제는 오직 브로커만 가능하며 파일 단위로 이루어지는데 이 단위를  '로그 세그먼트(log segment)'라고 한다
- 세그먼트에는 다수의 데이터가 들어있기 때문에 일반적인 데이터베이스처럼 특정 데이터를 선별해서 삭제할 수 없다
- CleanUp Policy라고 하는 delete 옵션에 의해서 특정 시간, 용량에 따라서 삭제를 수행할 수 있고 혹은 특수한 상황에서 Compact 옵션을 주게되면 가장 최신의 메시지/KEY 가 있는 레코드를 제외하고 나머지 메시지/KEY 가 있는 레코드를 삭제 할 수도있다
```
`컨슈머의 오프셋 저장` :
* 컨슈머가 토픽에서 데이터를 가져가면 어느 위치까지 가져갔는지 commit을 하게되는데 이때 __consumer_offsets 토픽에 저장한다.
* __consumer_offsets 토픽은 자동으로 생성되어 자동으로 관리되기 때문에 Internal 토픽이라고 부른다

`그룹 코디네이커`:
* 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배하는 역할을 한다
* 일반적으로 파티션과 컨슈머는 1:1 매칭되는데 특정 컨슈머에 문제가 생길경우 문제가 발생한 컨슈머와 매칭되어있던 파티션이 다른 문제없는 파티션을 바라보도록 재할당(`리밸런스(rebalance)`) 하여 데이터가 끊임없이 처리되도록 도와준다