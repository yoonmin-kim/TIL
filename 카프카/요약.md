### 카프카 기본개념
* 카프카: 카프카 클러스터를 포함한 이벤트 스트림 프로세싱 아키텍처.
* 브로커: 카프카 클러스터의 서버 중 하나. 데이터를 저장하고 전달하는 역할.
* 토픽: 카프카 클러스터에서 데이터를 구분하는 단위. 토픽은 최소 1개 이상의 파티션을 가지고 있음.
* 파티션: 토픽에서 데이터를 논리적으로 구분하는 단위.
* 레코드: 메시지를 담는 가장 작은 크기.
  * 오프셋: 프로듀서가 보낸 데이터가 브로커에 저장되었을 때 받는 고유한 번호.
  * 타임스탬프: 레코드가 프로듀서에서 생성되었을 때 시간(또는 브로커에 적재된 시간)
  * 헤더: 레코드의 특징을 담는 키/값 저장소.
  * 메시지 키: 데이터를 구분하는 값. 파티셔너는 메시지 키를 토대로 파티션을 지정.
  * 메시지 값: 실질적으로 처리하고자 하는 데이터.
* ISR: 동기화가 완료된 리더, 팔로워 파티션 묶음.

### 카프카 프로듀서
* 카프카 프로듀서: 카프카 브로커로 데이터를 전달하는 역할을 하는 애플리케이션.
* 파티셔너: 메시지 키를 토대로 파티션을 지정하는 class. 커스텀 클래스를 사용하여 로직 변경 가능.
* 어큐뮤레이터: 레코드 전송시 배치로 묶는 역할.
* acks: 레코드를 카프카 클러스터로 전송시 전달 신뢰성을 지정.
* min.insync.replicas: acks=all일 경우 최소 적재 보장 파티션 개수.
* enable.idempotence: 멱등성 프로듀서로 동작하기 위해 설정하는 옵션.
* transactional.id: 트랜잭션 프로듀서로 동작하기 위해 설정하는 옵션.

### 카프카 컨슈머
* 카프카 컨슈머: 카프카 클러스터에 저장된 레코드를 받아와서 처리하는 애플리케이션.
* 컨슈머 그룹: 동일한 역할을 하는 컨슈머 들의 묶음.
* 컨슈머 랙: 파티션에서 가장 최근의 레코드 오프셋과 컨슈머 오프셋간의 차이.
* 커밋: 컨슈머가 레코드 처리가 완료되었을 경우 카프카 클러스터에 마지막으로 읽은 레코드의 오프셋 번호를 저장하는 작업
* 리밸런싱: 컨슈머 그룹에서 컨슈머 개수의 변화 또는 파티션 개수의 변화로 인해 할당이 변경되는 작업.
* auto.offset.reset: 컨슈머 그룹이 없을 경우 처음 읽을 오프셋의 위치를 지정하는 옵션.
* isolation.level: 트랜잭션이 완료된 레코드를 읽을 것인지 판단하는 옵션.